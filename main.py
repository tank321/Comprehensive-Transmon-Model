"""
Main Script for Transmon Qubit Cosmic Ray Impact Simulation
=============================================================

This script runs the complete simulation pipeline in the correct order:
1. Energy Deposit: Bethe-Bloch calculation for muon energy deposition
2. Phonon Dynamics: Ballistic phonon transport from Si substrate to Al film
3. RT Equations: Rothwarf-Taylor equations for quasiparticle dynamics
4. T1 Calculation: Coherence time degradation and recovery

Author: Generated with Claude Code
Date: 2025-10-16
"""

import subprocess
import sys
import time
import os
import shutil
from pathlib import Path
from datetime import datetime

# Get the project root directory
PROJECT_ROOT = Path(__file__).parent.resolve()

# Define the simulation modules in execution order
SIMULATION_MODULES = [
    {
        'name': 'Energy Deposit (Bethe-Bloch)',
        'script': 'energy_deposit/bethe.py',
        'description': 'Calculate muon energy deposition in silicon substrate'
    },
    {
        'name': 'Phonon Dynamics',
        'script': 'phonon_dynamics/phonon_diffusion_solver.py',
        'description': 'Simulate ballistic phonon transport to qubit'
    },
    {
        'name': 'RT Equations',
        'script': 'rt_equations/solve_rt_equations.py',
        'description': 'Solve Rothwarf-Taylor equations for QP dynamics'
    },
    {
        'name': 'T1 Calculation',
        'script': 't1_calculation/plot_gamma_qp.py',
        'description': 'Calculate T1 coherence time degradation and recovery'
    }
]


def print_header(text, char='=', width=80):
    """Print a formatted header"""
    print('\n' + char * width)
    print(text.center(width))
    print(char * width + '\n')


def print_section(text, char='-', width=80):
    """Print a formatted section header"""
    print('\n' + char * width)
    print(text)
    print(char * width)


def run_module(module_info, module_num, total_modules):
    """Run a single simulation module"""
    script_path = PROJECT_ROOT / module_info['script']

    print_section(
        f"MODULE {module_num}/{total_modules}: {module_info['name']}",
        char='='
    )
    print(f"Description: {module_info['description']}")
    print(f"Script: {module_info['script']}")
    print(f"Starting at: {time.strftime('%Y-%m-%d %H:%M:%S')}")
    print()

    # Check if script exists
    if not script_path.exists():
        print(f"ERROR: Script not found at {script_path}")
        return False

    # Run the script
    start_time = time.time()
    try:
        result = subprocess.run(
            [sys.executable, str(script_path)],
            cwd=str(PROJECT_ROOT),
            capture_output=True,
            text=True,
            check=True
        )

        # Print the captured output so it appears in both terminal and log file
        if result.stdout:
            print(result.stdout, end='')
        if result.stderr:
            print(result.stderr, end='', file=sys.stderr)

        elapsed_time = time.time() - start_time
        print(f"\nCompleted in {elapsed_time:.2f} seconds")
        print(f"Status: SUCCESS")
        return True

    except subprocess.CalledProcessError as e:
        elapsed_time = time.time() - start_time

        # Print any output that was generated before the failure
        if e.stdout:
            print(e.stdout, end='')
        if e.stderr:
            print(e.stderr, end='', file=sys.stderr)

        print(f"\nFailed after {elapsed_time:.2f} seconds")
        print(f"Status: FAILED")
        print(f"Error code: {e.returncode}")
        return False
    except Exception as e:
        elapsed_time = time.time() - start_time
        print(f"\nFailed after {elapsed_time:.2f} seconds")
        print(f"Status: FAILED")
        print(f"Error: {str(e)}")
        return False


class Tee:
    """Utility class to write output to both terminal and file"""
    def __init__(self, *files):
        self.files = files

    def write(self, data):
        for f in self.files:
            f.write(data)
            f.flush()

    def flush(self):
        for f in self.files:
            f.flush()


def collect_output_files(output_folder):
    """Collect all plots generated by the simulation and move them to output folder"""
    plot_files = [
        # Energy Deposit plots
        PROJECT_ROOT / "energy_deposit" / "energy_deposit_summary.png",
        # Phonon Dynamics plots
        PROJECT_ROOT / "phonon_dynamics" / "ballistic_phonon_flux_and_heatmap.png",
        # RT Equations plots
        PROJECT_ROOT / "rt_equations" / "RT_0D_with_phonon_injection.png",
        # T1 Calculation plots
        PROJECT_ROOT / "t1_calculation" / "gamma_qp_dual_axis.png",
        PROJECT_ROOT / "t1_calculation" / "xqp_and_T1_vs_time.png",
        PROJECT_ROOT / "t1_calculation" / "gamma_qp_and_xqp_vs_time_ms.png",
    ]

    moved_files = []
    for plot_file in plot_files:
        if plot_file.exists():
            dest_file = output_folder / plot_file.name
            shutil.move(str(plot_file), str(dest_file))
            moved_files.append(plot_file.name)

    return moved_files


def main():
    """Main execution function"""
    # Create output folder with timestamp
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    output_folder = PROJECT_ROOT / f"simulation_run_{timestamp}"
    output_folder.mkdir(exist_ok=True)

    # Create log file in the output folder
    log_filename = output_folder / "simulation_log.txt"

    # Open log file and redirect stdout/stderr
    with open(log_filename, 'w', encoding='utf-8') as log_file:
        # Save original stdout/stderr
        original_stdout = sys.stdout
        original_stderr = sys.stderr

        # Redirect to both terminal and file
        sys.stdout = Tee(original_stdout, log_file)
        sys.stderr = Tee(original_stderr, log_file)

        try:
            print_header(
                "TRANSMON QUBIT COSMIC RAY IMPACT SIMULATION\n"
                "Complete Pipeline Execution",
                char='='
            )

            print(f"Project directory: {PROJECT_ROOT}")
            print(f"Python executable: {sys.executable}")
            print(f"Total modules to run: {len(SIMULATION_MODULES)}")
            print(f"Start time: {time.strftime('%Y-%m-%d %H:%M:%S')}")
            print(f"Output folder: {output_folder}")
            print(f"Log file: {log_filename}")

            # Track execution statistics
            start_time_total = time.time()
            results = []

            # Run each module in sequence
            for i, module_info in enumerate(SIMULATION_MODULES, start=1):
                success = run_module(module_info, i, len(SIMULATION_MODULES))
                results.append({
                    'module': module_info['name'],
                    'success': success
                })

                # Stop if a module fails
                if not success:
                    print_section("PIPELINE ABORTED DUE TO FAILURE", char='!')
                    break

            # Print summary
            elapsed_time_total = time.time() - start_time_total
            print_header("EXECUTION SUMMARY", char='=')

            print(f"Total execution time: {elapsed_time_total:.2f} seconds "
                  f"({elapsed_time_total/60:.2f} minutes)")
            print(f"Modules completed: {sum(r['success'] for r in results)}/{len(SIMULATION_MODULES)}")
            print()

            # Print individual module results
            print("Module Results:")
            for i, result in enumerate(results, start=1):
                status = "SUCCESS" if result['success'] else "FAILED"
                symbol = "✓" if result['success'] else "✗"
                try:
                    print(f"  {i}. {result['module']}: {status}")
                except UnicodeEncodeError:
                    # Fallback for terminals that don't support Unicode
                    print(f"  {i}. {result['module']}: {status}")

            # Overall status
            all_success = all(r['success'] for r in results)
            print()
            if all_success:
                print("OVERALL STATUS: ALL MODULES COMPLETED SUCCESSFULLY")
                print()

                # Collect and move plot files to output folder
                print_section("COLLECTING OUTPUT FILES", char='-')
                print("Moving plot files to output folder...")
                moved_files = collect_output_files(output_folder)

                print(f"\nMoved {len(moved_files)} plot files to {output_folder.name}:")
                for filename in moved_files:
                    print(f"  - {filename}")

                print("\nData files (remain in module directories):")
                print("  - energy_deposit/energy_deposit_data.pkl")
                print("  - phonon_dynamics/phonon_injection_data.pkl")
                print("  - rt_equations/xqp_vs_time_data.pkl")

                return 0
            else:
                print("OVERALL STATUS: PIPELINE FAILED")
                failed_modules = [r['module'] for r in results if not r['success']]
                print(f"Failed modules: {', '.join(failed_modules)}")
                return 1

        finally:
            # Restore original stdout/stderr
            sys.stdout = original_stdout
            sys.stderr = original_stderr


if __name__ == '__main__':
    exit_code = main()
    sys.exit(exit_code)
